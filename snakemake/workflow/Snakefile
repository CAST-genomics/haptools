import warnings
from pathlib import Path
import snakemake.io as io
from snakemake.utils import min_version

##### set minimum snakemake version #####
min_version("6.7.0")


# IMPORT CONFIG VARIABLES
configfile: "config/config.yml"


def check_config(value, default=False, place=config, as_set=False):
    """return true if config value exists and is true"""
    value = place[value] if (value in place and place[value]) else default
    return (set(value) if isinstance(value, list) else {value}) if as_set else value


# handle defaults
config["out"] = check_config("out", "out")
config["superpop"] = check_config("superpop", "EUR")
config["min_maf"] = check_config("min_maf", 0)
config["mode"] = check_config("mode", "snp", as_set=True)
config["beta"] = check_config("beta", 0.1, as_set=True)
config["exclude_causal"] = check_config("exclude_causal", False, as_set=True)
# remove any trailing slashes in directories and set the variables
out = str(Path(config["out"]))
logs = out + "/logs"
bench = out + "/bench"
# parse loci
loci = {loc["locus"].replace(":", "_"): loc for loc in config["loci"]}
# convert the exclude_causal var into a dict for later
exclude_causal = {("in", "ex")[val]: val for val in config["exclude_causal"]}


def get_vcf_chrs(vcf_path):
    """return a dict of VCFs split by contig"""
    if io.contains_wildcard(vcf_path):
        return glob_wildcards(vcf_path).chr
    return []


chrs = get_vcf_chrs(config["ref_panel"])


rule all:
    input:
        expand(
            out + "/{locus}/sim/{mode}/{beta}/{causal}clude/results/susie.pdf",
            locus=loci.keys(),
            beta=config["beta"],
            mode=config["mode"],
            causal=exclude_causal.keys(),
        ),


rule vcf2gt:
    """ convert a VCF into a genotype matrix (cols are vars and rows are samples) """
    input:
        vcf=config["ref_panel"],
        vcf_idx=config["ref_panel"] + ".tbi",
        samps=config["samples"],
    params:
        popn=config["superpop"],
        locus=lambda wildcards: loci[wildcards.chr + "_" + wildcards.locus]["locus"],
    output:
        matrix=out + "/{chr}_{locus}/matrix.tsv.gz",
    log:
        logs + "/{chr}_{locus}/vcf2gt",
    conda:
        "envs/default.yml"
    shell:
        "workflow/scripts/matrix.bash {params.popn} '{params.locus}' "
        "{input.vcf} {input.samps} 2>{log} | gzip > {output.matrix}"


rule str2gt:
    """ sum the difference of each allele length from the reference allele length """
    input:
        matrix=out + "/{locus}/matrix.tsv.gz",
    params:
        maf=config["min_maf"],
    output:
        matrix=out + "/{locus}/gt_matrix.tsv.gz",
    log:
        logs + "/{locus}/str2gt",
    conda:
        "envs/default.yml"
    shell:
        "workflow/scripts/gt_matrix.py -o {output.matrix} -m {params.maf} {input.matrix} 2>{log}"


def phen_loc(wildcards):
    if config["mode"] == "snp":
        if "snp" in loci[wildcards.locus]:
            return "--snp-loc " + loci[wildcards.locus]["snp"].split(":")[1]
        return "--max-vars 1"
    else:
        return "--str-loc " + loci[wildcards.locus]["str"].split(":")[1]


rule phens:
    """ generate phenotypes from the genotype matrix """
    input:
        matrix=rules.str2gt.output,
    params:
        loc=phen_loc,
        beta=lambda wildcards: wildcards.beta,
        mode=lambda wildcards: wildcards.mode,
    output:
        phenotypes=out + "/{locus}/sim/{mode}/{beta}/phens.tsv.gz",
    log:
        logs + "/{locus}/sim/{mode}/{beta}/phens",
    conda:
        "envs/default.yml"
    shell:
        "workflow/scripts/generate_phenotypes.py -o {output.phenotypes} "
        "--beta-{params.mode} {params.beta} {params.loc} -- {input.matrix} &>{log}"


run_methods_out = out + "/{locus}/sim/{mode}/{beta}/{causal}clude/method_output"


rule run_methods:
    """
    run the methods FINEMAP and SuSie
    and generate plots with results
    """
    input:
        gt=rules.phens.input,
        phen=rules.phens.output,
    params:
        outdir=run_methods_out,
        exclude_causal=lambda wildcards: int(exclude_causal[wildcards.causal]),
    output:
        sumstats=temp(run_methods_out + "/sumstats.rds"),
        finemap=run_methods_out + "/finemap.rds",
        susie=run_methods_out + "/susie.rds",
    log:
        logs + "/{locus}/sim/{mode}/{beta}/{causal}clude/methods",
    conda:
        "envs/susie.yml"
    shell:
        "workflow/scripts/finemapping_methods.R {input} {params} &>{log}"


plot_results_out = out + "/{locus}/sim/{mode}/{beta}/{causal}clude/results"


rule plot_results:
    """create plots to summarize the results of the simulations"""
    input:
        gt=rules.phens.input,
        finemap=rules.run_methods.output.finemap,
        susie=rules.run_methods.output.susie,
    params:
        outdir=plot_results_out,
    output:
        finemap_pdf=plot_results_out + "/finemap.pdf",
        susie_pdf=plot_results_out + "/susie.pdf",
        # susie_eff_pdf=temp(plot_results_out + "/susie_eff.pdf"),
    log:
        logs + "/{locus}/sim/{mode}/{beta}/{causal}clude/results",
    conda:
        "envs/susie.yml"
    script:
        "scripts/summarize_results.R"
